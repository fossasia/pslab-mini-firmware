/**
 * @file platform.c
 * @brief Platform hardware initialization implementation for STM32H563xx
 *
 * This file implements the platform hardware initialization for the PSLab Mini
 * firmware running on STM32H563xx microcontrollers. It provides the primary
 * system setup including clock configuration and core hardware initialization.
 *
 * Clock Configuration Summary:
 * - Input: 8 MHz HSE (bypassed, from external oscillator)
 * - PLL1: 8 MHz HSE -> 2 MHz (÷4) -> 500 MHz VCO (×250) -> 250 MHz System Clock
 * (÷2)
 * - HSI48: 48 MHz internal oscillator (enabled for USB)
 * - System Clock: 250 MHz
 * - AHB Clock: 250 MHz (no division)
 * - APB1/2/3 Clocks: 250 MHz (no division)
 * - Flash Latency: 5 wait states for 250 MHz operation
 *
 * @author PSLab Team
 * @date 2025
 */
#include "platform.h"
#include "stm32h5xx_hal.h"

enum { SYSTEM_CLOCK_FREQ = 250000000U }; // 250 MHz
enum { SI_PREFIX_MEGA = 1000000U }; // 1 Mega = 10^6

// Define the clock types used in the platform
// Each type represents a specific clock source or bus clock
typedef enum {
    SYS_CLK,
    AHB_CLK,
    APB1_CLK,
    APB2_CLK,
    APB3_CLK,
} CLKType;

/**
 * @brief Configure the system clock to 250 MHz
 *
 * This function configures the STM32H563xx system clock for maximum performance
 * operation at 250 MHz. The configuration uses the external 8 MHz HSE
 * oscillator as the primary clock source through PLL1, and enables HSI48 for
 * USB operations.
 *
 * Clock Tree Configuration:
 * 1. HSE: 8 MHz external oscillator (bypassed mode)
 * 2. PLL1 Input: 8 MHz ÷ 4 = 2 MHz
 * 3. PLL1 VCO: 2 MHz × 250 = 500 MHz
 * 4. System Clock: 500 MHz ÷ 2 = 250 MHz
 * 5. HSI48: 48 MHz (for USB peripheral)
 *
 * Bus Clocks:
 * - AHB: 250 MHz (SYSCLK ÷ 1)
 * - APB1: 250 MHz (AHB ÷ 1)
 * - APB2: 250 MHz (AHB ÷ 1)
 * - APB3: 250 MHz (AHB ÷ 1)
 *
 * Power and Performance:
 * - Voltage scaling: Scale 0 (highest performance)
 * - Flash latency: 5 wait states
 * - PLL VCO range: Wide range for optimal performance
 *
 * @note This function was generated by STM32CubeMX
 * @note If any clock configuration fails, the system will hang to prevent
 *       hardware damage from incorrect timing
 *
 * @return None
 */

// NOLINTNEXTLINE: readability-function-cognitive-complexity
static void system_clock_config(void)
{
    RCC_OscInitTypeDef osc_init = { 0 };
    RCC_ClkInitTypeDef clk_init = { 0 };

    /* Configure the main internal regulator output voltage. */
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
    while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {
        ;
    }

    /* Initializes the RCC Oscillators according to the specified parameters
     * in the RCC_OscInitTypeDef structure.
     */
    osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI48;
    osc_init.HSEState = RCC_HSE_BYPASS;
    osc_init.HSI48State = RCC_HSI48_ON;
    osc_init.PLL.PLLState = RCC_PLL_ON;
    osc_init.PLL.PLLSource = RCC_PLL1_SOURCE_HSE;
    osc_init.PLL.PLLM = 4; // 8 MHz / 4 = 2 MHz input
    osc_init.PLL.PLLN =
        SYSTEM_CLOCK_FREQ / SI_PREFIX_MEGA; // 2 MHz * 250 = 500 MHz VCO
    osc_init.PLL.PLLP = 2; // 500 MHz / 2 = 250 MHz system clock
    osc_init.PLL.PLLQ = 2; // 500 MHz / 2 = 250 MHz peripheral clock
    osc_init.PLL.PLLR = 2; // 500 MHz / 2 = 250 MHz peripheral clock
    osc_init.PLL.PLLRGE = RCC_PLL1_VCIRANGE_1;
    osc_init.PLL.PLLVCOSEL = RCC_PLL1_VCORANGE_WIDE;
    osc_init.PLL.PLLFRACN = 0;
    if (HAL_RCC_OscConfig(&osc_init) != HAL_OK) {
        /* Clock configuration incorrect or hardware failure. Hang the system to
         * prevent damage.
         */
        while (1);
    }

    // Wait for HSI48.
    while (!__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY)) {
    }

    /* Initializes the CPU, AHB and APB buses clocks. */
    clk_init.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
                         RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 |
                         RCC_CLOCKTYPE_PCLK3;
    clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;
    clk_init.APB1CLKDivider = RCC_HCLK_DIV1;
    clk_init.APB2CLKDivider = RCC_HCLK_DIV1;
    clk_init.APB3CLKDivider = RCC_HCLK_DIV1;
    if (HAL_RCC_ClockConfig(&clk_init, FLASH_LATENCY_5) != HAL_OK) {
        /* Clock configuration incorrect or hardware failure. Hang the system to
         * prevent damage.
         */
        while (1);
    }
}

/**
 * @brief Initialize the platform hardware
 *
 * This function performs the complete platform hardware initialization sequence
 * for the PSLab Mini system. It must be called immediately after system reset
 * and before any other initialization functions.
 *
 * Initialization sequence:
 * 1. HAL_Init(): Initialize the Hardware Abstraction Layer
 *    - Configure system tick timer (SysTick)
 *    - Initialize low-level hardware interfaces
 *    - Set up interrupt priorities
 *
 * 2. system_clock_config(): Configure system clocks
 *    - Set up 250 MHz system clock from external oscillator
 *    - Configure all peripheral clocks
 *    - Enable HSI48 for USB operations
 *
 * After this function completes successfully, the system will be running at
 * 250 MHz with all essential hardware initialized and ready for application
 * use.
 *
 * @note This function MUST be called before any other system initialization
 * @note If clock configuration fails, the system will hang
 *
 * @return None
 */
void PLATFORM_init(void)
{
    HAL_Init();
    system_clock_config();
}

/**
 * @brief SysTick interrupt handler for 1 ms timebase
 *
 * This interrupt service routine handles the SysTick timer interrupt which
 * provides a 1 millisecond timebase for the HAL library. The SysTick timer
 * is configured automatically by HAL_Init() and HAL_InitTick().
 *
 * The handler performs two essential functions:
 * 1. HAL_IncTick(): Increment the HAL millisecond tick counter
 * 2. HAL_SYSTICK_IRQHandler(): Handle any HAL-specific SysTick processing
 *
 * This timebase is used throughout the HAL library for:
 * - Timeout handling in blocking functions
 * - Delay functions (HAL_Delay)
 * - Time measurement utilities
 *
 * @note This function overrides the weak definition in stm32h5xx_hal.c
 * @note The SysTick timer is configured for 1 ms intervals at system clock
 * frequency
 * @note This handler runs at the highest interrupt priority to ensure accurate
 * timing
 *
 * @return None
 */
void SysTick_Handler(void)
{
    HAL_IncTick();
    HAL_SYSTICK_IRQHandler();
}

/**
 * @brief Get the clock speed for a specific clock type
 *
 * This function retrieves the clock speed for the specified clock type.
 * It can be used to determine the frequency of various system clocks such as
 * the system clock, AHB clock, and APB clocks.
 *
 * @param clk_type The type of clock to query (SYS_CLK, AHB_CLK, APB1_CLK,
 * APB2_CLK, APB3_CLK)
 *
 * @return The clock speed in Hz for the specified clock type, or 0 if invalid
 *         type is provided
 */
static uint32_t get_clock_speed(CLKType clk_type)
{
    if (clk_type == SYS_CLK) {
        return HAL_RCC_GetSysClockFreq();
    } else if (clk_type == AHB_CLK) {
        return HAL_RCC_GetHCLKFreq();
    } else if (clk_type == APB1_CLK) {
        return HAL_RCC_GetPCLK1Freq();
    } else if (clk_type == APB2_CLK) {
        return HAL_RCC_GetPCLK2Freq();
    } else if (clk_type == APB3_CLK) {
        return HAL_RCC_GetPCLK3Freq();
    } else {
        return 0; // Invalid clock type
    }
}

uint32_t get_peripheral_clock_speed(PeripheralClock *clock)
{
    if (*clock == TIMER2 || *clock == TIMER3 || *clock == TIMER4 ||
        *clock == TIMER5 || *clock == TIMER6 || *clock == TIMER7) {
        return get_clock_speed(APB1_CLK); // These timers use APB1 frequency
    } else if (*clock == TIMER1 || *clock == TIMER8 || *clock == TIMER16 ||
               *clock == TIMER17 || *clock == TIMER16 || *clock == TIMER17) {
        return get_clock_speed(APB2_CLK); // These timers use APB2 frequency
    } else {
        return 0; // Invalid timer clock
    }
}