/**
 * @file platform.c
 * @brief Platform hardware initialization implementation for STM32H563xx
 *
 * This file implements the platform hardware initialization for the PSLab Mini
 * firmware running on STM32H563xx microcontrollers. It provides the primary
 * system setup including clock configuration and core hardware initialization.
 *
 * Clock Configuration Summary:
 * - Input: 8 MHz HSE (bypassed, from external oscillator)
 * - PLL1: 8 MHz HSE -> 2 MHz (÷4) -> 500 MHz VCO (×250) -> 250 MHz System Clock
 * (÷2)
 * - PLL2: 8 MHz HSE -> 4 MHz (÷2) -> 300 MHz VCO (×75) -> 75 MHz ADC Clock (÷4)
 * - HSI48: 48 MHz internal oscillator (enabled for USB)
 * - System Clock: 250 MHz
 * - AHB Clock: 250 MHz (no division)
 * - APB1/2/3 Clocks: 250 MHz (no division)
 * - ADC Clock: 75 MHz (from PLL2R)
 * - Flash Latency: 5 wait states for 250 MHz operation
 *
 * @author PSLab Team
 * @date 2025
 */
#include "stm32h5xx_hal.h"

#include "util/error.h"
#include "util/logging.h"

#include "platform.h"

enum { SYSTEM_CLOCK_FREQ = 250000000U }; // 250 MHz
enum { SI_PREFIX_MEGA = 1000000U }; // 1 Mega = 10^6

// Define the clock types used in the platform
// Each type represents a specific clock source or bus clock
typedef enum {
    SYS_CLK,
    AHB_CLK,
    APB1_CLK,
    APB2_CLK,
    APB3_CLK,
} CLKType;

/**
 * @brief Configure the system clock to 250 MHz and ADC clock to 75 MHz
 *
 * This function configures the STM32H563xx system clock for maximum performance
 * operation at 250 MHz. The configuration uses the external 8 MHz HSE
 * oscillator as the primary clock source through PLL1, enables HSI48 for
 * USB operations, and configures PLL2 to provide a dedicated 75 MHz clock
 * for ADC peripherals.
 *
 * Clock Tree Configuration:
 * 1. HSE: 8 MHz external oscillator (bypassed mode)
 * 2. PLL1 Input: 8 MHz ÷ 4 = 2 MHz
 * 3. PLL1 VCO: 2 MHz × 250 = 500 MHz
 * 4. System Clock: 500 MHz ÷ 2 = 250 MHz
 * 5. PLL2 Input: 8 MHz ÷ 2 = 4 MHz
 * 6. PLL2 VCO: 4 MHz × 75 = 300 MHz
 * 7. ADC Clock: 300 MHz ÷ 4 = 75 MHz (from PLL2R)
 * 8. HSI48: 48 MHz (for USB peripheral)
 *
 * Bus Clocks:
 * - AHB: 250 MHz (SYSCLK ÷ 1)
 * - APB1: 250 MHz (AHB ÷ 1)
 * - APB2: 250 MHz (AHB ÷ 1)
 * - APB3: 250 MHz (AHB ÷ 1)
 *
 * Dedicated Peripheral Clocks:
 * - ADC1/ADC2: 75 MHz (from PLL2R)
 *
 * Power and Performance:
 * - Voltage scaling: Scale 0 (highest performance)
 * - Flash latency: 5 wait states
 * - PLL1 VCO range: Wide range for optimal performance
 * - PLL2 VCO range: Medium range for ADC clock generation
 *
 * @note This function was generated by STM32CubeMX and modified for PLL2
 * @note If any clock configuration fails, the system will hang to prevent
 *       hardware damage from incorrect timing
 *
 * @return None
 */

// NOLINTNEXTLINE: readability-function-cognitive-complexity
static void system_clock_config(void)
{
    RCC_OscInitTypeDef osc_init = { 0 };
    RCC_ClkInitTypeDef clk_init = { 0 };

    /* Configure the main internal regulator output voltage. */
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
    while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {
        ;
    }

    /* Initializes the RCC Oscillators according to the specified parameters
     * in the RCC_OscInitTypeDef structure.
     */
    osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI48;
    osc_init.HSEState = RCC_HSE_BYPASS;
    osc_init.HSI48State = RCC_HSI48_ON;
    osc_init.PLL.PLLState = RCC_PLL_ON;
    osc_init.PLL.PLLSource = RCC_PLL1_SOURCE_HSE;
    osc_init.PLL.PLLM = 4; // 8 MHz / 4 = 2 MHz input
    osc_init.PLL.PLLN =
        SYSTEM_CLOCK_FREQ / SI_PREFIX_MEGA; // 2 MHz * 250 = 500 MHz VCO
    osc_init.PLL.PLLP = 2; // 500 MHz / 2 = 250 MHz system clock
    osc_init.PLL.PLLQ = 2; // 500 MHz / 2 = 250 MHz peripheral clock
    osc_init.PLL.PLLR = 2; // 500 MHz / 2 = 250 MHz peripheral clock
    osc_init.PLL.PLLRGE = RCC_PLL1_VCIRANGE_1;
    osc_init.PLL.PLLVCOSEL = RCC_PLL1_VCORANGE_WIDE;
    osc_init.PLL.PLLFRACN = 0;

    if (HAL_RCC_OscConfig(&osc_init) != HAL_OK) {
        /* Clock configuration incorrect or hardware failure */
        THROW(ERROR_HARDWARE_FAULT);
    }

    // Wait for HSI48 to be ready (needed for USB)
    while (!__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY)) {
    }

    /* Initializes the CPU, AHB and APB buses clocks. */
    clk_init.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
                         RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 |
                         RCC_CLOCKTYPE_PCLK3;
    clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;
    clk_init.APB1CLKDivider = RCC_HCLK_DIV1;
    clk_init.APB2CLKDivider = RCC_HCLK_DIV1;
    clk_init.APB3CLKDivider = RCC_HCLK_DIV1;
    if (HAL_RCC_ClockConfig(&clk_init, FLASH_LATENCY_5) != HAL_OK) {
        /* Clock configuration incorrect or hardware failure */
        THROW(ERROR_HARDWARE_FAULT);
    }

    /* Configure peripheral clocks - Set ADC clock source to PLL2R (75 MHz) */
    RCC_PeriphCLKInitTypeDef periph_clk_init = { 0 };
    periph_clk_init.PeriphClockSelection = RCC_PERIPHCLK_ADCDAC;
    periph_clk_init.AdcDacClockSelection = RCC_ADCDACCLKSOURCE_PLL2R;

    // Configure PLL2 structure to match our desired configuration
    // This is required because HAL_RCCEx_PeriphCLKConfig calls
    // RCCEx_PLL2_Config internally
    periph_clk_init.PLL2.PLL2Source = RCC_PLL2_SOURCE_HSE;
    periph_clk_init.PLL2.PLL2M = 2; // 8 MHz / 2 = 4 MHz
    // NOLINTNEXTLINE: readability-magic-numbers
    periph_clk_init.PLL2.PLL2N = 75; // 4 MHz * 75 = 300 MHz VCO
    periph_clk_init.PLL2.PLL2P = 2; // 300 MHz / 2 = 150 MHz
    periph_clk_init.PLL2.PLL2Q = 2; // 300 MHz / 2 = 150 MHz
    periph_clk_init.PLL2.PLL2R = 4; // 300 MHz / 4 = 75 MHz (for ADC)
    periph_clk_init.PLL2.PLL2RGE = RCC_PLL2_VCIRANGE_1; // 2-4 MHz input range
    periph_clk_init.PLL2.PLL2VCOSEL =
        RCC_PLL2_VCORANGE_MEDIUM; // 150-420 MHz VCO
    periph_clk_init.PLL2.PLL2FRACN = 0;
    periph_clk_init.PLL2.PLL2ClockOut =
        RCC_PLL2_DIVR; // Enable PLL2R output for ADC

    if (HAL_RCCEx_PeriphCLKConfig(&periph_clk_init) != HAL_OK) {
        /* ADC clock configuration failed */
        THROW(ERROR_HARDWARE_FAULT);
    }
}

/**
 * @brief Initialize the platform hardware
 *
 * This function performs the complete platform hardware initialization sequence
 * for the PSLab Mini system. It must be called immediately after system reset
 * and before any other initialization functions.
 *
 * Initialization sequence:
 * 1. HAL_Init(): Initialize the Hardware Abstraction Layer
 *    - Configure system tick timer (SysTick)
 *    - Initialize low-level hardware interfaces
 *    - Set up interrupt priorities
 *
 * 2. system_clock_config(): Configure system clocks
 *    - Set up 250 MHz system clock from external oscillator
 *    - Configure all peripheral clocks
 *    - Enable HSI48 for USB operations
 *
 * After this function completes successfully, the system will be running at
 * 250 MHz with all essential hardware initialized and ready for application
 * use.
 *
 * @note This function MUST be called before any other system initialization
 * @note If clock configuration fails, the system will hang
 *
 * @return None
 */
void PLATFORM_init(void)
{
    if (HAL_Init() != HAL_OK) {
        THROW(ERROR_HARDWARE_FAULT);
    }

    system_clock_config();

    LOG_init();
    LOG_LL_INFO("Platform hardware initialized");
}

/**
 * @brief SysTick interrupt handler for 1 ms timebase
 *
 * This interrupt service routine handles the SysTick timer interrupt which
 * provides a 1 millisecond timebase for the HAL library. The SysTick timer
 * is configured automatically by HAL_Init() and HAL_InitTick().
 *
 * The handler performs two essential functions:
 * 1. HAL_IncTick(): Increment the HAL millisecond tick counter
 * 2. HAL_SYSTICK_IRQHandler(): Handle any HAL-specific SysTick processing
 *
 * This timebase is used throughout the HAL library for:
 * - Timeout handling in blocking functions
 * - Delay functions (HAL_Delay)
 * - Time measurement utilities
 *
 * @note This function overrides the weak definition in stm32h5xx_hal.c
 * @note The SysTick timer is configured for 1 ms intervals at system clock
 * frequency
 * @note This handler runs at the highest interrupt priority to ensure accurate
 * timing
 *
 * @return None
 */
void SysTick_Handler(void)
{
    HAL_IncTick();
    HAL_SYSTICK_IRQHandler();
}

uint32_t PLATFORM_get_tick(void)
{
    return HAL_GetTick();
}

/**
 * @brief Get the clock speed for a specific clock type
 *
 * This function retrieves the clock speed for the specified clock type.
 * It can be used to determine the frequency of various system clocks such as
 * the system clock, AHB clock, and APB clocks.
 *
 * @param clk_type The type of clock to query (SYS_CLK, AHB_CLK, APB1_CLK,
 * APB2_CLK, APB3_CLK)
 *
 * @return The clock speed in Hz for the specified clock type, or 0 if invalid
 *         type is provided
 */
static uint32_t get_clock_speed(CLKType clk_type)
{
    if (clk_type == SYS_CLK) {
        return HAL_RCC_GetSysClockFreq();
    }
    if (clk_type == AHB_CLK) {
        return HAL_RCC_GetHCLKFreq();
    }
    if (clk_type == APB1_CLK) {
        return HAL_RCC_GetPCLK1Freq();
    }
    if (clk_type == APB2_CLK) {
        return HAL_RCC_GetPCLK2Freq();
    }
    if (clk_type == APB3_CLK) {
        return HAL_RCC_GetPCLK3Freq();
    }
    return 0; // Invalid clock type
}

uint32_t PLATFORM_get_peripheral_clock_speed(PLATFORM_PeripheralClock clock)
{
    if (clock == PLATFORM_CLOCK_INVALID) {
        return 0;
    }
    if (clock == PLATFORM_CLOCK_ADC1 || clock == PLATFORM_CLOCK_ADC2) {
        return HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
    }
    if (clock == PLATFORM_CLOCK_TIMER2 || clock == PLATFORM_CLOCK_TIMER3 ||
        clock == PLATFORM_CLOCK_TIMER4 || clock == PLATFORM_CLOCK_TIMER5 ||
        clock == PLATFORM_CLOCK_TIMER6 || clock == PLATFORM_CLOCK_TIMER7) {
        return get_clock_speed(APB1_CLK);
    }
    if (clock == PLATFORM_CLOCK_TIMER1 || clock == PLATFORM_CLOCK_TIMER8 ||
        clock == PLATFORM_CLOCK_TIMER16 || clock == PLATFORM_CLOCK_TIMER17) {
        return get_clock_speed(APB2_CLK);
    }

    return 0; // Unknown clock
}

/**
 * @brief Reset the platform/system
 *
 * This function performs a software reset of the entire STM32H563xx system.
 * It uses the NVIC (Nested Vectored Interrupt Controller) system reset request
 * to trigger a complete system reset, equivalent to a hardware reset or power
 * cycle.
 *
 * The reset process:
 * 1. All registers are reset to their default values
 * 2. All peripherals are reset and disabled
 * 3. System clock configuration is reset to default (HSI)
 * 4. All GPIO pins are reset to their default state
 * 5. System restarts from the reset vector
 *
 * This is useful for:
 * - Recovering from error conditions
 * - Implementing software-triggered system restart
 * - Ensuring clean system state after configuration changes
 *
 * @note This function does not return - the system reset occurs immediately
 * @note All volatile memory content will be lost
 * @note Non-volatile settings (flash, backup registers) are preserved
 * @note Watchdog timers are reset
 */
__attribute__((noreturn)) void PLATFORM_reset(void)
{
    // Ensure all pending operations complete before reset
    __DSB(); // Data Synchronization Barrier
    __ISB(); // Instruction Synchronization Barrier

    NVIC_SystemReset();
    __builtin_unreachable();
}
