/**
 * @file platform.c
 * @brief Platform hardware initialization implementation for STM32H563xx
 * 
 * This file implements the platform hardware initialization for the PSLab Mini
 * firmware running on STM32H563xx microcontrollers. It provides the primary
 * system setup including clock configuration and core hardware initialization.
 * 
 * Clock Configuration Summary:
 * - Input: 8 MHz HSE (bypassed, from external oscillator)
 * - PLL1: 8 MHz HSE -> 2 MHz (÷4) -> 500 MHz VCO (×250) -> 250 MHz System Clock (÷2)
 * - HSI48: 48 MHz internal oscillator (enabled for USB)
 * - System Clock: 250 MHz
 * - AHB Clock: 250 MHz (no division)
 * - APB1/2/3 Clocks: 250 MHz (no division)
 * - Flash Latency: 5 wait states for 250 MHz operation
 * 
 * @author PSLab Team
 * @date 2025
 */

#include "stm32h5xx_hal.h"

/**
 * @brief Configure the system clock to 250 MHz
 * 
 * This function configures the STM32H563xx system clock for maximum performance
 * operation at 250 MHz. The configuration uses the external 8 MHz HSE oscillator
 * as the primary clock source through PLL1, and enables HSI48 for USB operations.
 * 
 * Clock Tree Configuration:
 * 1. HSE: 8 MHz external oscillator (bypassed mode)
 * 2. PLL1 Input: 8 MHz ÷ 4 = 2 MHz
 * 3. PLL1 VCO: 2 MHz × 250 = 500 MHz
 * 4. System Clock: 500 MHz ÷ 2 = 250 MHz
 * 5. HSI48: 48 MHz (for USB peripheral)
 * 
 * Bus Clocks:
 * - AHB: 250 MHz (SYSCLK ÷ 1)
 * - APB1: 250 MHz (AHB ÷ 1)
 * - APB2: 250 MHz (AHB ÷ 1)
 * - APB3: 250 MHz (AHB ÷ 1)
 * 
 * Power and Performance:
 * - Voltage scaling: Scale 0 (highest performance)
 * - Flash latency: 5 wait states
 * - PLL VCO range: Wide range for optimal performance
 * 
 * @note This function was generated by STM32CubeMX
 * @note If any clock configuration fails, the system will hang to prevent
 *       hardware damage from incorrect timing
 * 
 * @return None
 */
static void system_clock_config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    /* Configure the main internal regulator output voltage. */
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
    while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY))
    {
        ;
    }

    /* Initializes the RCC Oscillators according to the specified parameters
    * in the RCC_OscInitTypeDef structure.
    */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI48;
    RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
    RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLL1_SOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLM = 4; // 8 MHz / 4 = 2 MHz input
    RCC_OscInitStruct.PLL.PLLN = 250; // 2 MHz * 250 = 500 MHz VCO
    RCC_OscInitStruct.PLL.PLLP = 2; // 500 MHz / 2 = 250 MHz system clock
    RCC_OscInitStruct.PLL.PLLQ = 2; // 500 MHz / 2 = 250 MHz peripheral clock
    RCC_OscInitStruct.PLL.PLLR = 2; // 500 MHz / 2 = 250 MHz peripheral clock
    RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1_VCIRANGE_1;
    RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1_VCORANGE_WIDE;
    RCC_OscInitStruct.PLL.PLLFRACN = 0;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
    {
        /* Clock configuration incorrect or hardware failure. Hang the system to prevent
        * damage.
        */
        while(1);
    }

    // Wait for HSI48.
    while(!__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY)) {}

    /* Initializes the CPU, AHB and APB buses clocks. */
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
                                  RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 |
                                  RCC_CLOCKTYPE_PCLK3;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB3CLKDivider = RCC_HCLK_DIV1;
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
    {
        /* Clock configuration incorrect or hardware failure. Hang the system to prevent
        * damage.
        */
        while(1);
    }
}

/**
 * @brief Initialize the platform hardware
 * 
 * This function performs the complete platform hardware initialization sequence
 * for the PSLab Mini system. It must be called immediately after system reset
 * and before any other initialization functions.
 * 
 * Initialization sequence:
 * 1. HAL_Init(): Initialize the Hardware Abstraction Layer
 *    - Configure system tick timer (SysTick)
 *    - Initialize low-level hardware interfaces
 *    - Set up interrupt priorities
 * 
 * 2. system_clock_config(): Configure system clocks
 *    - Set up 250 MHz system clock from external oscillator
 *    - Configure all peripheral clocks
 *    - Enable HSI48 for USB operations
 * 
 * After this function completes successfully, the system will be running at
 * 250 MHz with all essential hardware initialized and ready for application use.
 * 
 * @note This function MUST be called before any other system initialization
 * @note If clock configuration fails, the system will hang
 * 
 * @return None
 */
void PLATFORM_init(void)
{
    HAL_Init();
    system_clock_config();
}

/**
 * @brief SysTick interrupt handler for 1 ms timebase
 * 
 * This interrupt service routine handles the SysTick timer interrupt which
 * provides a 1 millisecond timebase for the HAL library. The SysTick timer
 * is configured automatically by HAL_Init() and HAL_InitTick().
 * 
 * The handler performs two essential functions:
 * 1. HAL_IncTick(): Increment the HAL millisecond tick counter
 * 2. HAL_SYSTICK_IRQHandler(): Handle any HAL-specific SysTick processing
 * 
 * This timebase is used throughout the HAL library for:
 * - Timeout handling in blocking functions
 * - Delay functions (HAL_Delay)
 * - Time measurement utilities
 * 
 * @note This function overrides the weak definition in stm32h5xx_hal.c
 * @note The SysTick timer is configured for 1 ms intervals at system clock frequency
 * @note This handler runs at the highest interrupt priority to ensure accurate timing
 * 
 * @return None
 */
void SysTick_Handler(void)
{
    HAL_IncTick();
    HAL_SYSTICK_IRQHandler();
}
